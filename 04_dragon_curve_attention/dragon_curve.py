"""
Dragon Curve Generator for Hierarchical Fractal Attention Patterns

The Dragon Curve (also known as the Heighway Dragon or Jurassic Park Curve) is a
fractal generated by repeatedly folding a strip of paper in half and then unfolding
it to form 90-degree angles. This creates a self-similar pattern with beautiful
hierarchical properties ideal for attention weighting.

Key Properties:
- Self-similar: pattern at iteration n contains pattern at iteration n-1
- Never self-intersecting: path never crosses itself
- Natural hierarchy: alternating left/right turns at multiple scales
- Fractal dimension: approximately 1.52 (between 1D line and 2D plane)

Generation Algorithm:
    Start: single segment
    Iteration 1: L (one left turn)
    Iteration 2: L L R (left, left, right)
    Iteration 3: L L R L L R R L
    Pattern: append(prev_pattern, middle_turn, reverse_and_flip(prev_pattern))
"""

import torch
import torch.nn as nn
from typing import Tuple, List
import math


class DragonCurveGenerator(nn.Module):
    """
    Generate Dragon Curve fractal patterns for hierarchical attention weighting.

    The dragon curve is generated recursively using the paper-folding sequence.
    At iteration n, we have 2^n - 1 turns (creating 2^n segments).

    Args:
        max_iterations: Maximum recursion depth (typically 10-12)
                       Iteration n generates 2^n points
        normalize: Whether to normalize coordinates to [0, 1] range

    Example:
        >>> gen = DragonCurveGenerator(max_iterations=8)
        >>> pattern = gen.get_pattern(iteration=5)  # 32 points
        >>> coords = gen.get_coordinates(iteration=5)  # (32, 2) coordinates
    """

    def __init__(self, max_iterations: int = 10, normalize: bool = True):
        super().__init__()

        if max_iterations < 1:
            raise ValueError(f"max_iterations must be >= 1, got {max_iterations}")
        if max_iterations > 20:
            raise ValueError(f"max_iterations too large (>20): {max_iterations}, "
                           f"would generate {2**max_iterations} points")

        self.max_iterations = max_iterations
        self.normalize = normalize

        # Precompute turn patterns for all iterations
        # Turn sequence: 1 = left (90° CCW), -1 = right (90° CW)
        self.patterns = {}
        for i in range(1, max_iterations + 1):
            self.patterns[i] = self._generate_turn_pattern(i)

    def _generate_turn_pattern(self, iteration: int) -> torch.Tensor:
        """
        Generate turn pattern for given iteration using recursive paper-folding rule.

        The dragon curve turn sequence follows a beautiful recursive pattern:
        - Pattern(n) = Pattern(n-1) + LEFT + Reverse_Flip(Pattern(n-1))
        - Where Reverse_Flip flips L<->R and reverses order

        Args:
            iteration: Which iteration (1-indexed)

        Returns:
            Tensor of turns: +1 = left turn, -1 = right turn
            Length = 2^iteration - 1
        """
        if iteration == 1:
            # Base case: single left turn
            return torch.tensor([1], dtype=torch.float32)

        # Recursive case
        prev_pattern = self._generate_turn_pattern(iteration - 1)

        # Reverse and flip: reverse order + negate (left <-> right)
        reversed_flipped = torch.flip(-prev_pattern, dims=[0])

        # Combine: prev + middle_turn + reversed_flipped
        # Middle turn is always LEFT (1) for standard dragon curve
        middle_turn = torch.tensor([1], dtype=torch.float32)

        pattern = torch.cat([prev_pattern, middle_turn, reversed_flipped], dim=0)

        return pattern

    def _turns_to_coordinates(self, turns: torch.Tensor) -> torch.Tensor:
        """
        Convert turn sequence to 2D coordinates by walking the curve.

        Starting at origin (0, 0) facing right (direction=0), execute each turn
        and step forward one unit.

        Args:
            turns: Tensor of turns (+1 = left, -1 = right)

        Returns:
            Tensor of (x, y) coordinates, shape (num_points, 2)
            num_points = len(turns) + 1 (including starting point)
        """
        num_turns = len(turns)
        num_points = num_turns + 1

        # Initialize coordinates
        coords = torch.zeros(num_points, 2, dtype=torch.float32)

        # Direction vectors: [right, up, left, down]
        # Represented as indices: 0=right, 1=up, 2=left, 3=down
        direction_vecs = torch.tensor([
            [1, 0],   # right (0°)
            [0, 1],   # up (90°)
            [-1, 0],  # left (180°)
            [0, -1]   # down (270°)
        ], dtype=torch.float32)

        # Start at origin, facing right
        position = torch.tensor([0.0, 0.0])
        direction = 0  # Index into direction_vecs

        coords[0] = position

        # Execute each turn and step
        for i, turn in enumerate(turns):
            # Apply turn: +1 (left) means CCW rotation, -1 (right) means CW
            if turn > 0:  # Left turn (CCW)
                direction = (direction + 1) % 4
            else:  # Right turn (CW)
                direction = (direction - 1) % 4

            # Step forward in new direction
            position = position + direction_vecs[direction]
            coords[i + 1] = position

        return coords

    def get_pattern(self, iteration: int) -> torch.Tensor:
        """
        Get precomputed turn pattern for given iteration.

        Args:
            iteration: Which iteration (1 to max_iterations)

        Returns:
            Turn sequence tensor
        """
        if iteration < 1 or iteration > self.max_iterations:
            raise ValueError(f"iteration must be in [1, {self.max_iterations}], got {iteration}")

        return self.patterns[iteration]

    def get_coordinates(self, iteration: int) -> torch.Tensor:
        """
        Get 2D coordinates for dragon curve at given iteration.

        Args:
            iteration: Which iteration (1 to max_iterations)

        Returns:
            Coordinates tensor of shape (2^iteration, 2)
            Optionally normalized to [0, 1] range
        """
        turns = self.get_pattern(iteration)
        coords = self._turns_to_coordinates(turns)

        if self.normalize:
            # Normalize to [0, 1] range
            min_coords = coords.min(dim=0)[0]
            max_coords = coords.max(dim=0)[0]
            range_coords = max_coords - min_coords

            # Avoid division by zero
            range_coords = torch.where(range_coords > 0, range_coords, torch.ones_like(range_coords))

            coords = (coords - min_coords) / range_coords

        return coords

    def verify_self_similarity(self, iteration: int) -> Tuple[bool, str]:
        """
        Verify self-similarity property: pattern(n) contains pattern(n-1).

        Args:
            iteration: Which iteration to check (must be >= 2)

        Returns:
            (is_similar, message): bool and descriptive message
        """
        if iteration < 2:
            return True, "Cannot check self-similarity for iteration < 2"

        pattern_curr = self.get_pattern(iteration)
        pattern_prev = self.get_pattern(iteration - 1)

        # Current pattern should start with previous pattern
        if len(pattern_curr) < len(pattern_prev):
            return False, f"Current pattern shorter than previous"

        # Check if first len(prev) elements match
        matches = torch.allclose(pattern_curr[:len(pattern_prev)], pattern_prev, atol=1e-6)

        if matches:
            return True, f"Pattern {iteration} contains pattern {iteration-1} (self-similar)"
        else:
            return False, f"Pattern {iteration} does NOT contain pattern {iteration-1}"

    def get_fractal_dimension(self) -> float:
        """
        Return the theoretical fractal dimension of the dragon curve.

        The Heighway dragon has a fractal dimension of approximately 1.5236.
        This is between a 1D line (dimension 1) and a 2D plane (dimension 2).

        Returns:
            Fractal dimension (theoretical value)
        """
        # Theoretical fractal dimension of Heighway dragon curve
        # Approximately 1.5236 (exact value is not a simple closed form)
        return 1.5236

    def get_hierarchical_weights(
        self,
        iteration: int,
        decay_rate: float = 0.8
    ) -> torch.Tensor:
        """
        Generate hierarchical attention weights based on dragon curve depth.

        The dragon curve naturally creates hierarchy: early turns affect global
        structure, later turns affect local details. We assign higher weights
        to earlier (more global) turns.

        Args:
            iteration: Which iteration pattern to use
            decay_rate: How quickly weights decay (0 < decay_rate < 1)
                       Higher = more uniform, Lower = more emphasis on early turns

        Returns:
            Weights tensor of shape (2^iteration,) summing to 1.0
        """
        num_points = 2 ** iteration

        # Create exponentially decaying weights
        # Earlier positions (global structure) get higher weights
        indices = torch.arange(num_points, dtype=torch.float32)
        weights = decay_rate ** indices

        # Normalize to sum to 1
        weights = weights / weights.sum()

        return weights

    def visualize_pattern(self, iteration: int, width: int = 60) -> str:
        """
        Create ASCII visualization of dragon curve pattern.

        Args:
            iteration: Which iteration to visualize
            width: Width of visualization in characters

        Returns:
            ASCII art string
        """
        coords = self.get_coordinates(iteration)

        # Scale to grid
        coords_scaled = (coords * (width - 1)).long()
        coords_scaled = torch.clamp(coords_scaled, 0, width - 1)

        # Find bounding box
        min_x, max_x = coords_scaled[:, 0].min().item(), coords_scaled[:, 0].max().item()
        min_y, max_y = coords_scaled[:, 1].min().item(), coords_scaled[:, 1].max().item()

        height = max_y - min_y + 1
        grid_width = max_x - min_x + 1

        # Create grid
        grid = [[' ' for _ in range(grid_width)] for _ in range(height)]

        # Draw path
        for i, (x, y) in enumerate(coords_scaled):
            x_offset = x.item() - min_x
            y_offset = max_y - y.item()  # Flip Y for display

            if i == 0:
                grid[y_offset][x_offset] = 'S'  # Start
            elif i == len(coords) - 1:
                grid[y_offset][x_offset] = 'E'  # End
            else:
                grid[y_offset][x_offset] = '█'

        # Convert to string
        lines = [''.join(row) for row in grid]
        return '\n'.join(lines)
